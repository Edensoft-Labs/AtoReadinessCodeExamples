## \package Waf.DevelopmentTools.Syft
## \copydoc Syft

import textwrap
from typing import Optional

import waflib

from Waf.Building.Docker.DockerImage import DOCKER_FEATURE_NAME
from Waf.DevelopmentTools.DevelopmentTools import DevelopmentTools
from Waf.Projects.Project import Project
from Waf.Utilities import OpenFileInDefaultProgram, Platform
from Waf.Utilities.Filesystem import DecompressGzipFile

## Syft is an open-source command-line tool for generating Software Bills of Materials (SBOMs). This code supports using Syft to scan
## Docker images built by our build framework and generate CycloneDX JSON reports for downstream vulnerability analysis (e.g., via Trivy or Grype).
## For more information, see the official Syft documentation: https://github.com/anchore/syft.
##
## We have chosen the CycloneDX SBOM format instead of the Software Package Data eXchange (SPDX) format. This is because CycloneDX was 
## designed for supply-chain security: dependency graphs, cryptographic hashes, VEX, component pedigree, provenance, and build metadata.
## These map neatly onto DoD mandates for vulnerability management, software supply-chain risk assessments, runtime posture, artifact traceability,
## and so forth. Because of this, commercial scanners, SCA tools, and DoD-preferred platforms (Anchore Enterprise, Aqua, Sonatype, 
## etc.) all use CycloneDX more actively in security posture workflows. SPDX, by contrast, was historically a licensing document. 
## It can express security data, but it has not proven to be the industry-preferred format. Thus, this Waf command outputs SBOMs
## in CycloneDX format for easy interoperability with other tools.
class Syft(object):
    # CONSTANTS.
    ## The identifying name of the Syft executable program as a development tool within our Waf build framework.
    DEVELOPMENT_TOOL_NAME: str = 'SYFT'
    ## The name of the directory to store the SBOM reports in.
    SBOM_REPORT_DIRECTORY_NAME: str = 'SoftwareBillOfMaterialsReports'
    ## The name of the directory to store temporary unzipped Docker archives.
    TEMPORARY_ARCHIVE_DIRECTORY_NAME: str = 'SyftTempArchives'

    # STATIC METHODS.
    ## Creates the SBOM report directory.
    ## \param[in,out]   bld - The build context.
    ## \return  The SBOM report directory.
    @staticmethod
    def CreateSbomReportDirectory(bld: waflib.Build.BuildContext) -> waflib.Node.Node:
        # CREATE THE SBOM REPORT DIRECTORY.
        sbom_report_directory: waflib.Node.Node = bld.bldnode.make_node(Syft.SBOM_REPORT_DIRECTORY_NAME)
        sbom_report_directory.mkdir()
        return sbom_report_directory

    ## Creates the temporary archive directory for storing unzipped Docker archives.
    ## \param[in,out]   bld - The build context.
    ## \return  The temporary archive directory.
    @staticmethod
    def CreateTemporaryArchiveDirectory(bld: waflib.Build.BuildContext) -> waflib.Node.Node:
        # CREATE THE TEMPORARY ARCHIVE DIRECTORY.
        temporary_archive_directory: waflib.Node.Node = bld.bldnode.make_node(Syft.TEMPORARY_ARCHIVE_DIRECTORY_NAME)
        temporary_archive_directory.mkdir()
        return temporary_archive_directory

    ## Deletes the temporary archive directory. This method is useful to use when cleaning up the workspace.
    ## \param[in,out]  bld - The build context.
    @staticmethod
    def DeleteTemporaryArchiveDirectory(bld: waflib.Build.BuildContext):
        # DELETE THE TEMPORARY ARCHIVE DIRECTORY.
        temporary_archive_directory: waflib.Node.Node = bld.bldnode.make_node(Syft.TEMPORARY_ARCHIVE_DIRECTORY_NAME)
        if temporary_archive_directory.exists():
            temporary_archive_directory.delete()

    ## Gets the Docker image SBOM for a given project. Each project gets its own SBOM directory to organize reports
    ## in a way most useful for providing security evidence.
    ## \param[in,out]   project - The project to retrieve the report for.
    ## \return  The Docker image SBOM report for the project.
    @staticmethod
    def GetDockerImageSbomReport(project: waflib.TaskGen.task_gen) -> waflib.Node.Node:
        # CONSTRUCT THE SBOM REPORT FROM THE PROJECT.
        sbom_report_directory: waflib.Node.Node = project.bld.bldnode.make_node(Syft.SBOM_REPORT_DIRECTORY_NAME)
        project_sbom_directory: waflib.Node.Node = sbom_report_directory.make_node(project.name)
        sbom: waflib.Node.Node = project_sbom_directory.make_node('DockerImageSbom.json')
        return sbom 
        
    ## Gets the filesystem SBOM for a given project. The filesystem SBOM is generated by scanning a directory on the filesystem
    ## for software components (including those in dependency metadata files), rather than scanning a container image.
    ## \param[in,out]   project - The project to retrieve the report for.
    ## \param[in]   output_directory_name - Optional name for the directory underneath the overall SBOM reports directory where this SBOM should be placed.
    ##      If not provided, the SBOM will be placed in a directory named after the project. This allows an SBOM to be placed in a project directory other 
    ##      than that of the project from which it was generated. This is important to group SBOMs for a project's dependencies under that project, which
    ##      helps keep generated SBOMs organized. For example, if the YourWebApp project depends on React_JavaScript, and we are generating SBOMs for all of
    ##      YourWebApp, we want the React_JavaScript filesystem SBOM to be written to the YourWebApp/FilesystemSboms directory, not the React_JavaScript/FilesystemSboms directory.
    ## \return  The filesystem SBOM report for the project.
    @staticmethod
    def GetFilesystemSbomReport(project: waflib.TaskGen.task_gen, output_directory_name: Optional[str] = None) -> waflib.Node.Node:
        # CONSTRUCT THE SBOM REPORT FROM THE PROJECT.
        sbom_report_directory: waflib.Node.Node = project.bld.bldnode.make_node(Syft.SBOM_REPORT_DIRECTORY_NAME)
        # Use the specified directory name if provided, otherwise use the project's own name.
        output_directory_name_was_provided: bool = output_directory_name is not None
        directory_name: str = output_directory_name if output_directory_name_was_provided else project.name
        project_sbom_directory: waflib.Node.Node = sbom_report_directory.make_node(directory_name)
        # Always place filesystem SBOMs in an IndividualFiles subdirectory of the chosen directory to keep the main directory clean.
        # This is because filesystem SBOMs are usually meant to be merged with other SBOMs to produce a final SBOM. Ordinarily, these
        # filesystem SBOMs don't need to be directly referenced.
        individual_files_directory: waflib.Node.Node = project_sbom_directory.make_node('FilesystemSboms')
        sbom: waflib.Node.Node = individual_files_directory.make_node(f'{project.name}_FilesystemSbom.json')
        return sbom

    ## Executes a Syft SBOM generation against the container image from the provided project.
    ## The resulting SBOM is written to `{build_directory}/SoftwareBillOfMaterialsReports/{project_name}/ContainerSbom.json`.
    ## \param[in,out]   project - The project to generate an SBOM for.
    ## \return  The SBOM file if generation succeeded, None otherwise.
    @staticmethod
    def GenerateSbomForContainerImage(project: waflib.TaskGen.task_gen) -> Optional[waflib.Node.Node]:
        # VERIFY IF SYFT CAN ACTUALLY BE USED.
        platform_is_linux: bool = Platform.IsLinux()
        project_includes_docker_image: bool = any(valid_feature in Project(project).GetFeatures() for valid_feature in [DOCKER_FEATURE_NAME])
        syft_can_be_used: bool = (platform_is_linux and project_includes_docker_image)
        if not syft_can_be_used:
            # SYFT CANNOT BE USED IN THIS SCENARIO.
            waflib.Logs.warn(textwrap.dedent(f'''\
                Skipping Syft SBOM generation for project `{project.name}`. Generating container image SBOMs with Syft is only
                supported on Linux platforms for projects that build Docker images.'''))
            return None

        # GET THE PATH TO THE SYFT EXECUTABLE.
        syft_executable_filepath: str = DevelopmentTools.GetPath(project.env, Syft.DEVELOPMENT_TOOL_NAME)

        # GET THE PATH TO THE DOCKER IMAGE TAR GZ FILE.
        # The project should have been built before calling this method to ensure the Docker image file exists.
        default_tar_gz_filename: str = f'{project.image_name}.tar.gz'
        docker_image_tar_gz_relative_filepath: str = getattr(project, 'tar_gz_filepath', default_tar_gz_filename)
        docker_image_tar_gz_file: waflib.Node.Node = project.path.find_or_declare(docker_image_tar_gz_relative_filepath)

        # VERIFY THE DOCKER IMAGE TAR GZ FILE EXISTS.
        if not docker_image_tar_gz_file.exists():
            error_message: str = f'Docker image file does not exist at `{docker_image_tar_gz_file}`. Ensure the project was built before generating the SBOM.'
            waflib.Logs.error(error_message)
            return None

        # EXTRACT THE DOCKER IMAGE SO IT CAN BE SCANNED.
        # We save Docker images as .tar.gz files, but Syft can only scan Docker images as .tar files.
        # We have to extract the .tar file so the image can be scanned.
        temporary_archive_directory: waflib.Node.Node = Syft.CreateTemporaryArchiveDirectory(project.bld)
        docker_image_tar_filename: str = f'{project.image_name}.tar'
        docker_image_tar_file: waflib.Node.Node = temporary_archive_directory.make_node(docker_image_tar_filename)
        extraction_was_successful: bool = DecompressGzipFile(docker_image_tar_gz_file.abspath(), docker_image_tar_file.abspath())
        if not extraction_was_successful:
            # STOP ATTEMPTING TO PROCESS THIS PROJECT.
            # The unzip method has already provided visibility into the error.
            return None
        
        # GENERATE THE SBOM FOR THE CONTAINER IMAGE.
        sbom_report_file: waflib.Node.Node = Syft.GetDockerImageSbomReport(project)
        # Ensure the parent directory exists before writing.
        sbom_report_file.parent.mkdir()
        syft_scan_command: list[str] = [
            syft_executable_filepath,
            'scan',
            f'docker-archive:{docker_image_tar_file}',
            # As described above, we have chosen the CycloneDX SBOM format over SPDX for its supply-chain security focus and tool interoperability.
            '--output',
            # Syft specifically requires specifying the output in the form `FORMAT=FILEPATH`.
            f'cyclonedx-json={sbom_report_file}']
        SUCCESS_RETURN_CODE: int = 0
        return_code: int = project.bld.exec_command(syft_scan_command)
        sbom_generation_succeeded: bool = (SUCCESS_RETURN_CODE == return_code)
        if sbom_generation_succeeded:
            # INDICATE THAT THE SBOM WAS SUCCESSFULLY GENERATED.
            waflib.Logs.info(f'Syft Container Image SBOM for {project.name} saved to {sbom_report_file}')
        else:
            # PROVIDE VISIBILITY INTO THE ERROR.
            waflib.Logs.error(f'An error occurred while generating SBOM for `{docker_image_tar_file}`. See above for details.')

        # CLEAN UP THE TEMPORARY EXTRACTED DOCKER IMAGE.
        try:
            if docker_image_tar_file.exists():
                docker_image_tar_file.delete()
        except Exception as error:
            # PROVIDE VISIBILITY INTO THE ERROR.
            waflib.Logs.warn(f'Failed to remove temporary extracted Docker image `{docker_image_tar_file}`. Error: {error}')

        # OPEN THE SBOM REPORT, IF REQUESTED.
        sbom_report_exists: bool = sbom_report_file.exists()
        open_generated_files: bool = project.bld.options.open
        open_sbom_report: bool = (sbom_report_exists and open_generated_files)
        if open_sbom_report:
            OpenFileInDefaultProgram(sbom_report_file.abspath())
        
        # RETURN THE SBOM FILE IF GENERATION SUCCEEDED.
        return sbom_report_file if sbom_generation_succeeded else None

    ## Generates a Syft SBOM by scanning a filesystem directory. This is useful for scanning directories that contain dependency metadata
    ## not captured in the Waf dependency graph.
    ## \param[in,out]   project - The project to generate an SBOM for.
    ## \param[in]   directory_to_scan - The directory to scan.
    ## \param[in]   output_directory_name - Optional name for the directory underneath the overall SBOM reports directory where this SBOM should be placed. 
    ##      If not provided, the SBOM will be placed in a directory named after the project.
    ## \return  The SBOM file if generation succeeded, None otherwise.
    @staticmethod
    def GenerateSbomForFilesystem(project: waflib.TaskGen.task_gen, directory_to_scan: waflib.Node.Node, output_directory_name: Optional[str] = None) -> Optional[waflib.Node.Node]:
        # VERIFY IF SYFT CAN ACTUALLY BE USED.
        platform_is_linux: bool = Platform.IsLinux()
        syft_can_be_used: bool = platform_is_linux
        if not syft_can_be_used:
            # SYFT CANNOT BE USED IN THIS SCENARIO.
            waflib.Logs.warn(textwrap.dedent(f'''\
                Skipping Syft SBOM generation for project `{project.name}`. 
                Generating filesystem SBOMs with Syft is only supported on Linux platforms.'''))
            return None

        # GET THE PATH TO THE SYFT EXECUTABLE.
        syft_executable_filepath: str = DevelopmentTools.GetPath(project.env, Syft.DEVELOPMENT_TOOL_NAME)

        # VERIFY THE DIRECTORY TO SCAN EXISTS.
        if not directory_to_scan.exists():
            error_message: str = f'Directory to scan does not exist at `{directory_to_scan}`.'
            waflib.Logs.error(error_message)
            return None

        # GENERATE THE SBOM FOR THE FILESYSTEM DIRECTORY.
        sbom_report_file: waflib.Node.Node = Syft.GetFilesystemSbomReport(project, output_directory_name)
        # Ensure the parent directory exists before writing.
        sbom_report_file.parent.mkdir()
        # Run Syft to scan the directory.
        syft_scan_command: list[str] = [
            syft_executable_filepath,
            'scan',
            f'dir:{directory_to_scan}',
            # The --source-name flag sets the top-level component name in the SBOM metadata, which is 
            # important for identifying this SBOM when merging with other SBOMs using CycloneDX merge tools.
            '--source-name',
            project.name,
            # As described above, we have chosen the CycloneDX SBOM format over SPDX for its supply-chain security focus and tool interoperability.
            '--output',
            # Syft specifically requires specifying the output in the form `FORMAT=FILEPATH`.
            f'cyclonedx-json={sbom_report_file}']
        SUCCESS_RETURN_CODE: int = 0
        return_code: int = project.bld.exec_command(syft_scan_command)
        sbom_generation_succeeded: bool = SUCCESS_RETURN_CODE == return_code
        if sbom_generation_succeeded:
            # INDICATE THAT THE SBOM WAS SUCCESSFULLY GENERATED.
            waflib.Logs.info(f'Syft Filesystem SBOM for {project.name} saved to {sbom_report_file}')
        else:
            # PROVIDE VISIBILITY INTO THE ERROR.
            waflib.Logs.error(f'An error occurred while generating SBOM for `{directory_to_scan}`. See above for details.')

        # OPEN THE SBOM REPORT, IF REQUESTED.
        sbom_report_exists: bool = sbom_report_file.exists()
        open_generated_files: bool = project.bld.options.open
        open_sbom_report: bool = (sbom_report_exists and open_generated_files)
        if open_sbom_report:
            OpenFileInDefaultProgram(sbom_report_file.abspath())
        
        # RETURN THE SBOM FILE IF GENERATION SUCCEEDED.
        return sbom_report_file if sbom_generation_succeeded else None
